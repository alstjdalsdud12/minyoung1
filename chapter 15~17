chapter 15 (상품 등록 페이지 개발1)

1. 화면구성
Appbar - 최상단의 영역을 구성
    1. leading 옵션으로 페이지를 닫는 아이콘을 배치했습니다. 이벤트는 GetX의 Get.back을 사용하여 간단하게 처리했습니다.
    2. centerTitle을 true로 설정하여 제목이 중앙에 오게 했습니다.
    3. 상품 등록 입력값을 채운 후 서버로 데이터를 전송하기 위한 '완료' 버튼을 배치했습니다. 아직 이벤트는 연결하지 않았습니다.

2. 보디(입력필드)
입력 필드 값이 길어지거나 디바이스 해상도 차이로 화면이 잘릴 수 있으므로, 이를 방지하기 위해 SingleChildScrollView로 시작하겠습니다.
이제 Column 아래에 입력 폼을 하나씩 추가할 것입니다. 각 입력 폼은 별도의 위젯 클래스로 관리하겠습니다. 왜 하나의 위젯(ProductWritePage) 내에서 관리하지 않고 각각의 위젯으로 나눌까요? 간단히 설명하면 이렇게 해야 코드를 관리하기 쉬워지고 가독성이 좋아집니다. 플러터에서는 화면 구성이 복잡해질수록 들여쓰기가 깊어지는데, 이처럼 최대한 위젯을 쪼개면 유지 보수하는 데 용이합니다.

이미지는 최대 10장까지 추가할 수 있습니다. 여러 이미지가 추가되면 좌우로 스크롤할 수 있게 해야 합니다.
    1. 하지만 사용자 편의를 위해 이미지 선택 버튼은 항상 고정되어 있어야 합니다.
    2. 따라서 이미지 선택 버튼을 제외한 나머지 영역을 Expanded 위젯으로 확장하여 사용했습니다.

이어서 이미지 선택 버튼을 먼저 만들겠습니다. 이를 위해 _photoSelectIcon 위젯 함수를 작성합니다.

글 제목과 카테고리 선택 영역, 가격 입력 필드 영역, 상품 상세 설명 영역, 거래 희망장소 설정 영역, 하단 키보드 영역을 설정함

3. 이미지 제어 기능
이미지 선택 위젯 만들기 - 파일에 권한(퍼미션)을 등록
    1. 앨범 목록을 불러오기 위해 getAssetPathList 이벤트를 호출합니다. 반환된 albums는 클래스 변수로 지정하여 어디서든 접근할 수 있게 했습니다.
    2. getAssetPathList 이벤트의 type 옵션으로 이미지만 불러올지, 오디오 파일만 불러올지 또는 영상만 불러올지 등을 설정할 수 있습니다. 여기서는 이미지	만 불러오도록 RequestType.image를 사용했습니다.
    3. 필터를 통해 특정 크기 이상의 이미지를 불러오도록 설정할 수 있습니다.
    4. 정렬 순서를 createDate 기준의 최신순으로 보이도록 설정합니다. 5: 앨범을 불러왔으므로 앨범의 사진 목록을 불러오는 이벤트를 만들었습니다.

    1. 로드한 사진 정보를 저장하기 위해 imageList라는 변수를 만들었습니다.
    2. 앨범이 비어 있지 않은 상태에서 사진을 로드하도록 조건을 설정했습니다.
    3. 앨범의 첫 번째 데이터부터 불러오도록 설정했습니다. 한 번에 60개씩 불러오도록 설정했습니다.
    4. 불러온 사진을 imageList에 저장하고, 화면을 업데이트하기 위해 setState 함수를 사용했습니다.

마지막으로 이미지의 우상단을 선택하면 selectedImages에 값을 추가하고 이미지 삭제/선택수정 기능도 추가함

4. 카테고리 선택 기능 및 상태 관리
카테고리 선택 메뉴를 누르면 팝업이 뜹니다. 이 팝업에서 상품의 대략적인 카테고리를 선택할 수 있으며, 이를 통해 상품들을 그룹화할 수 있습니다.
이 기능은 레이어 팝업 형태로 작동하며, 이전 페이지의 배경이 유지된 채로 카테고리 메뉴 위젯이 상단에 표시됩니다.

5. 가격 상태 관리
사용자가 가격을 입력하다가 '나눔'버튼을 눌렀을때 가격이 '나눔'으로 적용이 되고 '0'원으로 입력해도 나눔으로 처리되게 함

6. 거래 희망 장소 상태 관리
거래 희망 장소를 관리하기 위해 지도 위젯이 필요합니다. 여러가지 지도 위젯 중 가장 사용하기 편한 flutter_map을 이용하겠습니다.
지도기능을 사용하려면 위치 권한이 필요합니다. 이를 위해 안드로이드와 iOS에서 권한을 설정합니다.
거래 희망 장소 메뉴를 선택했을때 Get.to 방식을 이용하여 페이지를 연결하겠습니다.
    1. 위치 권한이 허용되면 snapshot에서 위치 정보를 가져와 myLocation 변수에 저장합니다.
    2. myLocation 변수에 담긴 위치 정보를 FlutterMap 위젯의 중심(center)에 넣어줍니다. 이렇게 하면 지도 기 위치를 중심으로 로드됩니다.
    3. 지도를 조작할 수 있는 기능인 드래그(drag)와 핀치 줌(pinchZoom)을 설정합니다.
    4. TileLayer(타일 레이어)에는 OpenStreetMap을 사용했습니다. flutter_map의 장점은 다른 타일 레이어 서비스도 사용할 수 있다는 것입니다.
    5. 지도 위에 고정적인 위젯을 배치할 수 있는 옵션이 있습니다. 이를 통해 지도 위에 버튼이나 필요한 디자인 요소를 쉽게 추가할 수 있습니다.
사용자가 지도에서 원하는 위치를 선택하고, '선택 완료' 버튼을 눌러 거래 희망 장소를 저장 할 수 있습니다.


chapter 16 (상품 등록 페이지 개발2)

1. 입력 필드 유효성 검사
저장 기능을 구현하기 위해 입력 필드가 올바르게 입력되었는지, 확인하고, 결과에 따라 '완료'버튼을 활성화하거나 비활성화하는 유효성검사 기능을 추가
상품 등록 입력 필드 중 반드시 입력해야 하는 필드를 결정해야 합니다. 필수 항목은 이미지, 제목, 가격 정도로 가정하고 나머지 정보는 선택 사항으로 간주하고 진행하겠습니다. 그러면 모든 입력 필드가 수정될 때마다 저장할 수 있는지 아닌지를 확인해야 합니다.

2. 상품 등록 데이터 저장
_productRepository.saveProduct 함수를 통해 데이터를 데이터베이스에 저장합니다. 그리고 반환된 saveId가 있을 때만 사용자에게 메시지를 띄워서 안내합니다. 그런 다음 등록 페이지를 닫기 위해 Get.back(result: true)를 사용했습니다.
여기서 result에 true를 넣은 이유는 새로 등록된 상품이 화면에 반영되도록 새로고침하기 위함입니다.

3. 개선사항
    1. 로딩 처리: 상품 등록 후 '완료' 버튼을 누르면, 로딩 처리를 통해 사용자에게 업로드 및 데이터 저장 진행 중	임을 알릴 필요가 있습니다.
    2. 미비한 데이터 개선: 저장된 데이터를 확인해보면 해당 상품이 누구의 게시물인지 알 수 없습니다. 이를 해결하기 위해 owner에 대한 정보가 필요합니다. 또한 상품이 등록된 시간과 업데이트된 시간을 추가해야 합니다. 이렇게 하면 관련 관리 측면에서 유용할 뿐 아니라, 고객이 상품을 최신순으로 정렬할 수 있습니다. 그 외에도 상품이 몇 번 확인되었는지, 판매 중인지, 예약 중인지, 완료되었는지 등을 나타내는 상태 값도 필요합니다.

3-1. 로딩처리
로딩처리는 여러 페이지에서 필요할 때가 많습니다. 매번 페이지별로 로딩 상태를 구성하는 것은 번거로울 수 있습니다. 이를 개선하기 위해 하나의 공동 레이아웃(CommonLayout)을 만들어 필요할 때마다 로딩 처리를 사용할 수 있도록 하면 매우 편리할 것입니다. 공동 레이아웃과 controller를 만들어 모든 페이지에서 사용할 수 있게 하겠습니다.

3-2. 미비한 데이터 개선
지금까지 설계된 Product 모델은 사용자가 입력하는 정보를 바탕으로 설계되었습니다. 하지만 서비스 제공을 위해서는 눈에 보이지 않는 데이터도 고려하고 설계해야 합니다. 이제 Product 모델에 부족한 데이터를 추가해보겠습니다.

    1. docId: 상품 데이터의 고유 키로, 데이터 삭제와 업데이트에 사용됩니다.
    2. owner: 작성자의 정보를 담습니다.
    3. createdAt: 최초로 상품 데이터를 저장할 때 입력되며, 이후 업데이트되지 않습니다.
    4. updatedAt: 상품 정보가 수정될 때마다 갱신됩니다.
    5. viewCount: 사용자가 해당 상품을 몇 번 확인했는지를 측정합니다.
    6. status: 상품의 상태로 판매 중/예약 중/판매 완료 등으로 구분됩니다.
    7. likers: 내 상품을 관심 상품으로 저장한 사용자 정보를 담습니다.


chapter 17 (홈 화면 상품 리스트)

1. 데이터 로드
    1 . onInit가 호출될때 페이지에 상품을 보여주기 위해 _loadProductList()를 호출합니다.
    2 . _productRepository를 통해 getProducts 함수를 호출합니다. 이 함수는 모든 상품 데이터를 조회하는 역할을 합니다. 지금은 검색 조건이 없어서 모든 상품 리스트를 조회하지만 나중에 검색 조건을 추가하여 기능을 개선

    1. 검색 조건이 없기 때문에 products의 모든 데이터를 불러오게 됩니다.
    2. 결과가 있든 없든 반환 타입은 새로운 형태인 것 입니다. 이는 dart 3.x 버전에서 도입된 패턴 매칭 방식입니다. 이 방 식으로는 데이터를 반환합니다. 페이징을 고려하여 상품 리스트와 마지막 아이템을 함께 전달하는 방식으로 구현하겠습니다.

현재 상태로 앱을 다시 실행하면, print문으로 숫자 1이 출력됩니다. 이는 조회된 상품 데이터의 개 수를 나타냅니다. 테스트 데이터의 개수에 따라 출력되는 숫자는 다를 수 있습니다. 일단 몇 개든 상관없이 조회된 데이터를 화면에 보여주는 작업을 진행하겠습니다.

2. 상품 리스트 상태 관리 및 화면 처리
    1. 상품을 상태 관리할 수 있도록 Rx방식으로 선언했습니다.
    2. result 데이터를 productList에 addAll로 추가했습니다.

    1. 기존에 인덱스만 넘겨주던 부분은 이제는 Product 모델로 넘겨줍니다.
    2. product의 이미지 중 첫 번째 이미지를 보여줍니다.
    3. product의 title을 제목 부분에 넣어줍니다.
    4. 판매자 정보와 날짜를 표시하기 위해 subinfo 함수를 따로 만들었습니다. 이렇게 하는 이유는 Row로 묶어서 보기 좋게 그룹화하기 위해서이기도 하고, 들여쓰기를 줄여 코드의 가독성을 높이기 위해서이기도 합니다.
    5. 이름 영역에 판매자의 nickname을 적용합니다.
    6. 상품 등록 시간을 포매팅(formatting)하여 표시합니다.

3. 가격 표기 위젯 생성
마지막으로 가격이 표기된 일반 상품 또는 0원으로 표기된 나눔 상품인지를 보여야 합니다. 또한 판매 상품의 상태도 보여줘야 합니다.

    1. price가 0원이라면 나눔 상품으로 표시합니다.
    2. 가격을 표시할 때는 NumberFormat을 사용하여 보기 좋게 표시될 수 있도록 합니다.
    3. 가격 표시 앞에 판매 상태를 보여주기 위해 Row의 맨 앞에 상태 표시를 추가했습니다. 또한 상태 값에 따라 각기 다른 색상과 상태 표시를 넣었습니다.

지금 등록된 데이터는 나눔 상품이기 때문에, 나눔이 아닌 상품도 등록해보겠습니다.

    1. refresh 함수를 생성합니다.
    2. 기존의 productList 값을 초기화합니다.
    3. 새로운 데이터를 조회하기 위해 _loadProductList 함수를 호출합니다.

4. 페이징 처리
현재 상품 개수는 적지만 사용자가 앱을 사용할 때 페이징 처리는 꼭 필요합니다. 이제 홈 화면의 리스트에 페이징 처리를 추가해보겠습니다.
상품을 등록하다 보면 생성일자로 정렬되지 않고 랜덤하게 정렬되는 것을 알 수 있을 것입니다. 이 부분도 페이징 기능을 만들면서 함께 구현하겠습니다.

    1. 검색 조건을 생성했습니다. 홈 화면에서는 특정 계정의 상품을 볼 이유가 없고 상품 상태는 판매 중, 예약 중만 볼 수 있게 설정했습니다. 그리고 lastItem이 null이면 첫 페이지를 의미합니다.
    2. 상품을 등록한 후 화면을 새로고침할 때 데이터를 다시 불러오는데 이때 lastItem을 비워야 합니다.
    3. getProducts 함수에 searchOption을 넘겨서 검색 조건에 맞는 데이터를 불러올 수 있도록 처리합니다.

    1. getProducts 함수에 searchOption을 넘겨받기 위해 ProductSearchOption을 파라미터로 선언했습니다.
    2. ProductSearchOption 모델에서 만든 toQuery 메서드를 이곳에서 사용하게 됩니다.
    3. lastItem이 null이면(lastItem == null) 첫 페이지이므로 7개의 데이터를 조회하게 됩니다.
    4. lastItem이 있는 경우, 페이징을 위해 startAfterDocument로 설정하고 7개의 데이터를 조회합 니다.

    1. 화면에서 ListView에 사용할 scrollController를 생성합니다.
    2. 페이징 시 반복 호출을 방지하기 위해 로딩(isLoading) 상태를 추가했습니다.
    3. onInit 함수에서 scrollController의 스크롤 이벤트를 추적하기 위해 _event 함수를 호출합니다.
    4. _event 함수는 스크롤 위치를 확인하여 페이지의 마지막 위치 -100에 도달했을 때, lastItem이 있고 로딩 중 이 아니라면 _loadProductList를 호출한 다음 페이지를 불러옵니다.
    5. _loadProductList를 호출할 때 동시에 isLoading 상태를 true로 변경합니다. 이렇게 하면 스크롤에 중복 호 출이 되지 않습니다.
    6. lastItem 조건에 따라 검색 필터 모델에 추가합니다.
    7. 데이터 처리가 끝난 후 로딩 상태를 false로 변경하여, 다시 다음 페이지를 호출할 수 있는 상태로 만들어줍니다.

홈 화면까지 개발완료
